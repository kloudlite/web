---
title: "Rethinking Development Environments & Workspaces: A Networking Solution Over Infrastructure"
metaTitle: "Rethinking Development Environments & Workspaces: A Networking Solution Over Infrastructure"
author: "Karthik Thirumalasetti"
authorEmail: "karthik001@me.com"
gravatarHash: "3613c388f0507bbbd89a8a6e7a0f3f79bbe49a779d34eafdaede663b3f2a2542"
date: "2024-09-03"
category: "engineering"
tags: [Distributed Environment, Distributed Development, Development Environments]
description: "Learn the difference between development workspaces and environments in this in-depth guide. Explore how developers traditionally set up environments, common issues with workspace and environment connections, and innovative solutions like network-based testing for faster development cycles. Understand the key components of workspaces, such as IDEs, libraries, runtimes, and debugging tools, versus environments that host databases, APIs, and services. Discover how two-way connections between workspaces and environments can streamline development workflows and boost productivity"
---

Imagine you're building a car. Your workspace is like your well-equipped garage—where you have all your tools,
spare parts, and workbenches to fine-tune every component. The environment, on the other hand, is the road system—with
traffic lights, highways, and gas stations—where the car will eventually run.

Both are essential but serve different purposes. In software development, understanding the distinction between workspaces
and environments is crucial for efficiency. Let’s dive deeper into how developers traditionally set up environments, and
what can be done to rethink this approach.

## What Is a Workspace?

A workspace is your personal developer toolkit. It’s where you write, test, and debug your code—all in one place.

### Your workspace includes:
- **IDE (Integrated Development Environment):** Tools like VS Code or IntelliJ where you write your code.
- **Libraries & Frameworks:** Such as Node.js, React, or Python that help your code run.
- **Runtimes:** The environment in which your code executes.
- **Debugging Tools:** Tools for finding and fixing bugs in your code.

It’s your playground, where you control every aspect of the development process.

> **Example: Building an E-commerce App**
>
> In your workspace, you might have:
> - Code editors for writing frontend and backend code.
> - Node.js and React running your application locally.
> - Docker containerizing your app for consistency.
> - Testing frameworks like Jest or Mocha for unit tests.

As a developer, whether you work on backend or frontend, your workspace is tailored to your needs, ensuring efficiency in building and testing your code.

## What Is an Environment?

An environment is the ecosystem where your application runs. It provides all the resources your app needs to operate properly.

### Your environment includes:
- **Databases:** Like MySQL or MongoDB to store your data.
- **APIs & Microservices:** External services that your app communicates with.
- **Message Queues:** Such as RabbitMQ or Kafka for handling asynchronous tasks.
- **Backend Services:** For handling processes like authentication and payment.

> **Example: The E-commerce App**
>
> Beyond just the code, your app needs a database to store products and users, a payment gateway for transactions, and services for user authentication. These components make up the environment where your app operates.

### Types of environments:
- **Development Environments:** Used for coding and testing, often on local machines or remote servers. These environments are frequently adjusted by developers.
- **Staging Environments:** Mimic production environments, used for final testing before release.
- **Production Environments:** Where your app serves real users and operates in its live state.

## Working with Development Environments and Workspaces

Developers typically set up environments on remote servers or local machines and connect their workspaces to them.
They often use tools like Docker Compose to spin up environments locally or cloud tools to manage remote setups.

Testing code typically requires deploying it to the environment. Developers may also remove services in the environment 
and route requests to their workspace for testing, using tools like Tailscale or Telepresence to save time by avoiding 
constant builds and deployments.

## Problems with Connecting Workspaces and Environments

Connecting workspaces and environments often involves juggling configs, secrets, and multiple setups. Developers switch between 
environments by tweaking configs, but this change is usually one-directional. The environment remains unaware of the workspace's 
existence, as it operates independently.

Take a backend developer working on a service that is called by a frontend service. To test whether changes in the backend affect 
the frontend, they must deploy their code to the environment and test it. Changing configs to route downstream services to the workspace 
isn’t feasible in most cases, especially in remote environments.

Because of this, many developers prefer to create isolated local environments where they can configure services and test code before deploying 
it to a shared environment.

## Two-Way Connection Between Workspaces and Environments

What if we could establish a two-way connection between workspaces and environments? This approach would allow developers to test their code 
without going through CICD pipelines or deploying to the environment, saving time and increasing efficiency.

### Existing Solutions:

**1. Build & Deploy:**
- Developer changes the code in the workspace.
- The code goes through the build and deployment process on local machine and update the environment.
- Examples: **Squash, Skaffold, Garden.**

**2. File Sync:**
- Developer changes code in the workspace.
- The code syncs to the environment, builds, and runs in the environment.
- Examples: **Ksync, Okteto.**

**3. Network-based Solutions:**
- Developer changes code in the workspace.
- A proxy service in the remote environment redirects traffic to the workspace for testing.
- Examples: **mirrord.dev, Telepresence, Kloudlite.**

Among these, **network-based solutions** offer the shortest development loop, enabling developers to test their code with 
downstream services without having to build and deploy every time.

## Why Does This Development Cycle Matter?

This loop is crucial for productivity. The faster you can test your code, the quicker you can iterate and improve. This is especially true in microservices architectures, where interdependencies between services require constant integration and testing. Shortening the development loop with two-way connections accelerates the development process and boosts overall efficiency.

By rethinking how we connect workspaces and environments—through networking solutions instead of traditional infrastructure setups—we can save time, reduce complexity, and ultimately create a better development experience.